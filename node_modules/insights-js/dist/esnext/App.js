import * as parameters from "./parameters";
import { isInBrowser, isReferrerSameHost, getHost } from "./utils";
/**
 * The default options.
 */
const defaultOptions = {};
/**
 * A class that contains a `projectId` and related configuration to track events painlessly.
 */
export class App {
    constructor(projectId, options = defaultOptions) {
        this.projectId = projectId;
        this.options = options;
        this.uniques = {};
        // variables used when tracking pages
        this.trackPageData = null;
        this.trackPageChange = this.trackPageChange.bind(this);
        this.trackLastPageTimeSpent = this.trackLastPageTimeSpent.bind(this);
    }
    /**
     * Track an occurence of the given event.
     *
     * @param event {TrackEventPayload} The event to track.
     */
    track(event) {
        if (this.options.disabled || !isInBrowser()) {
            return Promise.resolve();
        }
        if (event.unique) {
            const stringified = JSON.stringify(event);
            if (this.uniques[stringified])
                return Promise.resolve();
            this.uniques[stringified] = true;
        }
        const body = {
            id: event.id,
            projectId: this.projectId,
            ignoreErrors: this.options.ignoreErrors || false
        };
        if (event.remove)
            body.remove = true;
        if (event.parameters)
            body.parameters = event.parameters;
        if (event.update)
            body.update = true;
        // do not use fetch, for IE compatibility
        const request = new XMLHttpRequest();
        request.open("post", "https://getinsights.io/app/tics", true);
        request.setRequestHeader("Content-Type", "application/json");
        request.send(JSON.stringify(body));
    }
    /**
     * Tracks page views. This method checks if the URL changed every so often and tracks new pages accordingly.
     *
     * @param options The options to use for the tracking
     *
     * @returns An object of the form `{ stop(): void }` to stop the tracking
     */
    trackPages(options) {
        if (!isInBrowser()) {
            return { stop() { } };
        }
        if (this.trackPageData) {
            return this.trackPageData.result;
        }
        // Start tracking page changes
        const interval = setInterval(this.trackPageChange, 2000);
        // Calculate the data
        const { hash = false, search = false } = options || {};
        this.trackPageData = {
            hash,
            search,
            path: parameters.path(hash, search).value,
            isOnFirstPage: true,
            time: Date.now(),
            result: {
                stop() {
                    clearInterval(interval);
                }
            }
        };
        // Track the first/current page view
        this.trackSinglePage(true, this.trackPageData.path);
        window.addEventListener("unload", this.trackLastPageTimeSpent);
        return this.trackPageData.result;
    }
    getPreviousPage(first) {
        const dataPath = this.trackPageData && this.trackPageData.path;
        if (!first && dataPath) {
            return dataPath;
        }
        if (isReferrerSameHost()) {
            return document.referrer.replace(getHost(), "");
        }
        return document.referrer;
    }
    trackPageChange() {
        if (!this.trackPageData)
            return;
        const { hash, search } = this.trackPageData;
        const newPath = parameters.path(hash, search).value;
        if (newPath !== this.trackPageData.path) {
            this.trackSinglePage(false, newPath);
        }
    }
    trackSinglePage(first, path) {
        if (!this.trackPageData)
            return;
        this.trackPageData.isOnFirstPage = first && !isReferrerSameHost();
        const { time, isOnFirstPage } = this.trackPageData;
        const params = {
            path
        };
        if (isOnFirstPage) {
            params.uniqueViews = path;
            params.referrer = parameters.referrer();
            params.locale = parameters.locale();
            params.screenType = parameters.screenType();
        }
        const previous = this.getPreviousPage(first);
        if (previous && previous !== path) {
            params.transitions = parameters.transition(previous, path);
            if (!isOnFirstPage) {
                const now = Date.now();
                this.trackPageData.time = now;
                params.duration = parameters.durationInterval(now - time, previous + " - ");
            }
        }
        this.trackPageData.path = path;
        this.track({
            id: "page-views",
            parameters: params
        });
    }
    trackLastPageTimeSpent() {
        const time = this.trackPageData && this.trackPageData.time;
        if (!time || typeof navigator.sendBeacon !== "function" || this.options.disabled || !this.trackPageData) {
            return;
        }
        const { isOnFirstPage, path } = this.trackPageData;
        const params = {};
        // add the duration
        params.duration = parameters.durationInterval(Date.now() - time, path + " - ");
        const nextUrl = (document.activeElement && document.activeElement.href) || "";
        const host = getHost();
        if (!nextUrl) {
            // user closed the window
            params.bounces = isOnFirstPage ? "Yes" : "No";
        }
        else if (nextUrl[0] !== "/" && nextUrl.substr(0, host.length) !== getHost()) {
            // link outside of the app
            params.transitions = parameters.transition(path, nextUrl);
        }
        // polyfil for IE, this won't always work, but it's better than nothing.
        navigator.sendBeacon =
            navigator.sendBeacon ||
                function (url, body) {
                    const request = new XMLHttpRequest();
                    request.open("post", url, false);
                    request.send(body);
                };
        navigator.sendBeacon("https://getinsights.io/app/tics", JSON.stringify({
            id: "page-views",
            projectId: this.projectId,
            parameters: params,
            ignoreErrors: this.options.ignoreErrors || false,
            update: true
        }));
    }
}
//# sourceMappingURL=App.js.map